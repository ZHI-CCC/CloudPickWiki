---
title: 界面间通信-消息总线(事件聚合器)
date: 2099-03-05 21:25:02
permalink: /js/界面间通信-消息总线(事件聚合器)
categories:
  - 脚本
tags:
  - 脚本
---
# 界面间通信-消息总线(事件聚合器)

为了让不同的UI界面之间能够互相通信和协作，系统提供了一个消息总线（或称事件聚合器）机制。通过消息总线，一个界面可以发布消息，而其他界面可以订阅这些消息并作出响应，从而实现解耦的界面间通信。

## 🤖 API 详解与脚本示例

### 核心方法
| 方法 | 说明 |
| :--- | :--- |
| **`MessageBus.publish(identifier, ...args)`** | **发布消息**。用于从任何UI控件中发布消息。第一个参数 `identifier` 是消息的唯一标识符，后续参数是可选的，用于传递消息携带的数据。 |
| **`events.listener`  `messageBusReceive(event)`** |  **订阅消息**。在任何控件的 `events` 中，通过 `listener` 事件可以订阅消息总线的消息。  |

### 综合示例
以下示例演示了如何在一个UI控件中发布消息，以及在另一个UI控件中订阅并接收消息。

#### 1. 发布消息 (控件A)
```javascript
// 假设这是某个控件A的JavaScript代码，可以通过任何方式触发 (例如，按钮点击事件)
MessageBus.publish('my_custom_event', 'a', 55, true, 'bb');

//  参数说明:
//  'my_custom_event'  - 消息标识符 (用于区分不同的消息类型)
//  'a', 55, true, 'bb'  - 传递给订阅者的消息数据 (可以是任意类型的数据)
```

#### 2. 订阅消息并接收数据 (控件B)
```yaml
# 假设这是另一个控件B的YAML配置
- !TextBlock
  name: myTextBlock
  text: "等待消息..."
  events:
    listener: |
      function messageBusReceive(event) {
        // 确保接收到的事件是目标事件
        if (event.getIdentifier() == 'my_custom_event') {
          // 获取消息携带的数据
          var data = event.getData();
          
          // 根据消息携带的数据更新文本内容
          myTextBlock.text = "收到了消息: " + data.get(0) + ", " + data.get(1) + ", " + data.get(2) + ", " + data.get(3);
        }
      }
```

#### 🔍 说明
1.  **发布消息**：控件A通过 `MessageBus.publish()` 方法发布了一个名为 `'my_custom_event'` 的消息。同时，它还传递了一些数据： `'a'`, `55`, `true`, 和 `'bb'`。
2.  **订阅消息**：控件B通过 `listener` 事件订阅了消息。
3.  **接收消息**：当 `'my_custom_event'` 消息被发布时，控件B中的 `messageBusReceive()` 函数会被自动调用。
4.  **处理数据**：`messageBusReceive()` 函数首先检查事件的标识符，确认接收到的消息是它所关心的。然后，它使用 `event.getData()` 方法获取消息携带的数据，并利用这些数据更新了 `myTextBlock` 的文本内容。

通过这种方式，控件A和控件B实现了松耦合的通信。 控件A不需要知道控件B的存在，同样控件B也不需要知道控件A，它们只需要通过消息总线进行交互即可。 这使得UI的组织和维护更加容易。