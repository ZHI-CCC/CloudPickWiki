---
title: importClass importPackage
date: 2099-03-05 21:25:02
permalink: /js/importClassimportPackage
categories:
  - 脚本
tags:
  - 脚本
---
# `importClass` 与 `importPackage` 

## 概述

这是一种在 JavaScript 环境中直接访问 Java 类库的特殊语法机制。该机制允许 JavaScript 代码无缝调用 Java 类、创建 Java 对象、访问静态成员，并实现两种语言之间的深度集成。

## 指令说明

### `importClass` 指令

**语法**
```javascript
importClass(fullyQualifiedClassName);
```

**功能**
将指定的 Java 类导入当前 JavaScript 作用域，使该类名可以直接使用，无需完整包路径。

**参数**
- `fullyQualifiedClassName`：Java 类的完全限定名（包名+类名），以字符串形式表示

**示例**
```javascript
// 导入 ArrayList 类
importClass(java.util.ArrayList);

// 使用简化的类名创建对象
var list = new ArrayList();

// 调用对象方法
list.add("元素1");
list.add("元素2");

// 输出对象内容
print(list); // 输出: [元素1, 元素2]
```

**等效 Java 代码**
```java
import java.util.ArrayList;

public class Example {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("元素1");
        list.add("元素2");
        System.out.println(list);
    }
}
```

### `importPackage` 指令

**语法**
```javascript
importPackage(packageName);
```

**功能**
将指定 Java 包中的所有公开类导入当前 JavaScript 作用域，使这些类都可以直接使用。

**参数**
- `packageName`：Java 包名，以字符串形式表示

**示例**
```javascript
// 导入 java.util 包中的所有类
importPackage(java.util);

// 可以直接使用包中的任何类
var list = new ArrayList();
var map = new HashMap();
var date = new Date();

// 操作对象
map.put("键名", "值内容");
print(map.get("键名")); // 输出: 值内容
```

**注意事项**
- 可能引起命名冲突（如果不同包中有同名类）
- 建议在明确需要多个类时使用

## 核心特性

### 1. 对象创建与构造器调用
```javascript
// 创建 Java 对象
importClass(java.io.File);
var file = new File("/path/to/file.txt");

// 调用带参数的构造器
importClass(java.net.URL);
var url = new URL("http://example.com");
```

### 2. 方法调用
```javascript
importClass(java.lang.StringBuilder);
var builder = new StringBuilder();

// 调用实例方法
builder.append("Hello");
builder.append(" ");
builder.append("World");

var result = builder.toString();
print(result); // 输出: Hello World
```

### 3. 静态成员访问
```javascript
importClass(java.lang.Math);

// 访问静态字段
var pi = Math.PI;

// 调用静态方法
var max = Math.max(10, 20);
var random = Math.random();

print("圆周率: " + pi);
print("较大值: " + max);
```

### 4. 方法重载支持
```javascript
importClass(java.lang.String);

var str = new String("Hello");

// 调用不同的重载方法
var char1 = str.charAt(0);      // 返回字符
var substring = str.substring(1, 3);  // 返回子串
```

## 进阶用法

### 1. 继承与接口实现
```javascript
// 实现 Java 接口
importClass(java.lang.Runnable);

var task = new Runnable({
    run: function() {
        print("JavaScript 中实现的 run() 方法");
    }
});

// 扩展 Java 类（需谨慎使用）
importClass(java.io.Writer);
var customWriter = new (Java.extend(java.io.Writer))({
    write: function(buffer, offset, length) {
        // 自定义实现
    },
    flush: function() {
        // 自定义实现
    },
    close: function() {
        // 自定义实现
    }
});
```

### 2. 异常处理
```javascript
importClass(java.io.FileReader);

try {
    var reader = new FileReader("不存在的文件.txt");
} catch (e) {
    // e 是 Java 异常对象
    print("捕获到异常: " + e);
    print("异常消息: " + e.getMessage());
}
```

### 3. 数组操作
```javascript
// 创建 Java 数组
importClass(java.lang.reflect.Array);

// 创建 int 数组
var intArray = Array.newInstance(java.lang.Integer.TYPE, 5);

// 访问数组元素
intArray[0] = 100;
intArray[1] = 200;

print("数组长度: " + intArray.length);
print("第一个元素: " + intArray[0]);
```

### 4. 集合框架集成
```javascript
importPackage(java.util);

// 使用各种集合类
var linkedList = new LinkedList();
var hashSet = new HashSet();
var treeMap = new TreeMap();

// 操作集合
hashSet.add("元素A");
hashSet.add("元素B");

// 迭代器使用
var iterator = hashSet.iterator();
while (iterator.hasNext()) {
    print("集合元素: " + iterator.next());
}
```

## 命名空间管理

### 避免命名冲突
```javascript
// 方法1：使用完整限定名（不导入）
var list = new java.util.ArrayList();
var date = new java.util.Date();

// 方法2：选择性导入
importClass(java.util.ArrayList);
importClass(java.util.HashMap);

// 方法3：使用别名
var JavaUtil = java.util;
var list = new JavaUtil.ArrayList();
```

### 作用域控制
```javascript
// 导入只在当前作用域有效
(function() {
    importPackage(java.awt);
    var color = new Color(255, 0, 0);
    // 这里可以直接使用 Color 类
})();

// 这里 Color 类不可用（除非再次导入）
```

## 性能优化建议

1. **减少导入范围**
   ```javascript
   // 不推荐：导入整个包
   importPackage(java.util);
   
   // 推荐：只导入需要的类
   importClass(java.util.ArrayList);
   importClass(java.util.HashMap);
   ```

2. **复用对象**
   ```javascript
   importClass(java.text.SimpleDateFormat);
   
   // 创建一次，多次使用
   var formatter = new SimpleDateFormat("yyyy-MM-dd");
   
   function formatDate(date) {
       return formatter.format(date);
   }
   ```

3. **避免频繁的对象创建**
   ```javascript
   // 不推荐：在循环内创建格式化对象
   for (var i = 0; i < 1000; i++) {
       var formatter = new SimpleDateFormat("yyyy-MM-dd"); // 重复创建
       // ...
   }
   
   // 推荐：在循环外创建
   var formatter = new SimpleDateFormat("yyyy-MM-dd");
   for (var i = 0; i < 1000; i++) {
       // 使用同一个格式化对象
       // ...
   }
   ```

## 兼容性说明

### 类型转换规则
| JavaScript 类型 | Java 类型 |
|----------------|-----------|
| `number` | `int`, `double`, `float` 等数值类型 |
| `string` | `String`, `char` |
| `boolean` | `boolean`, `Boolean` |
| `object` | `Map`, `Object` |
| `array` | 数组或 `List` |
| `function` | SAM 类型（单一抽象方法接口） |

### 注意事项

1. **null 处理**
   ```javascript
   // JavaScript 的 null 对应 Java 的 null
   var str = null;
   // 传递到 Java 方法时保持为 null
   ```

2. **undefined 处理**
   ```javascript
   // JavaScript 的 undefined 可能转换为 null 或抛出异常
   var value;
   // 传递给 Java 时通常变为 null
   ```

3. **方法签名匹配**
   ```javascript
   importClass(java.util.Collections);
   
   var list = new ArrayList();
   list.add(1);
   list.add(2);
   
   // JavaScript 数字自动匹配最合适的重载方法
   Collections.sort(list);
   ```

## 错误处理与调试

### 常见错误
```javascript
// 错误：未导入类
try {
    var list = new ArrayList(); // 抛出错误：ArrayList 未定义
} catch (e) {
    print("错误: " + e);
}

// 正确做法
importClass(java.util.ArrayList);
var list = new ArrayList(); // 正常工作
```

### 调试技巧
```javascript
// 1. 检查对象类型
importClass(java.util.ArrayList);
var list = new ArrayList();
print("对象类型: " + Object.prototype.toString.call(list));
print("Java 类名: " + list.getClass().getName());

// 2. 查看可用方法
var methods = list.getClass().getMethods();
for (var i = 0; i < methods.length; i++) {
    print("方法: " + methods[i].getName());
}
```

## 安全考虑

1. **类加载限制**
   - 某些 Java 类可能受安全管理器限制
   - 反射操作可能需要特殊权限

2. **资源管理**
   ```javascript
   importClass(java.io.BufferedReader);
   importClass(java.io.FileReader);
   
   // 正确资源管理
   var reader = null;
   try {
       reader = new BufferedReader(new FileReader("file.txt"));
       // 使用 reader
   } finally {
       if (reader != null) {
           reader.close();
       }
   }
   ```

3. **执行上下文隔离**
   - 建议在沙箱环境中运行不可信代码
   - 限制可访问的 Java 类和包

## 示例应用

### 配置文件解析
```javascript
importClass(java.util.Properties);
importClass(java.io.FileInputStream);

function loadConfig(configPath) {
    var props = new Properties();
    var input = new FileInputStream(configPath);
    
    try {
        props.load(input);
        
        // 转换为 JavaScript 对象
        var config = {};
        var entries = props.entrySet().iterator();
        
        while (entries.hasNext()) {
            var entry = entries.next();
            config[entry.getKey()] = entry.getValue();
        }
        
        return config;
    } finally {
        input.close();
    }
}

// 使用
var config = loadConfig("app.properties");
print("数据库地址: " + config["db.url"]);
```

### 动态任务调度
```javascript
importPackage(java.util.concurrent);

function scheduleTask(taskFunction, delay, period) {
    var executor = Executors.newScheduledThreadPool(1);
    
    var runnable = new Runnable({
        run: taskFunction
    });
    
    // 安排定期执行
    var future = executor.scheduleAtFixedRate(
        runnable, 
        delay, 
        period, 
        TimeUnit.SECONDS
    );
    
    return {
        cancel: function() {
            future.cancel(false);
            executor.shutdown();
        }
    };
}

// 使用
var scheduledTask = scheduleTask(
    function() {
        print("定时任务执行: " + new Date());
    },
    0,  // 初始延迟
    5   // 执行间隔（秒）
);

// 稍后取消
// scheduledTask.cancel();
```